import pandas as pd
import numpy as np
import sys
import os
from tabulate import tabulate
def is_number(s):
    try:
        float(s)
        return True
    except ValueError:
        return False

class pest_pst:
    def __init__(self, pestmode='estimation', ss=False, control=None, **kw):
        self.pestmode = pestmode.lower()
        self.par = None
        self.obs = None
        self.pargp = None
        self.tied = None
        self.prior = None
        self.obsgp = []
        self.tpl = []
        self.ins = []
        self.pp = []
        self.cmd = ''
        self.ss = ss
        self.nprior = 0
        self.control_kw = {}

        if control is not None:
            # control section default
            control = control.iloc[:, :4]
            control.columns = ['LINE', 'NAME', 'DEFAULT', 'VALUE']
            for i, r in control.dropna(subset=['VALUE']).set_index('NAME').iterrows():
                self.control_kw[i] = r.VALUE
        self.control_kw ['pestmode'] = self.pestmode


    def add_pargp(self, df):
        df = df.loc[:, 'PARGPNME INCTYP DERINC DERINCLB FORCEN DERINCMUL DERMTHD'.split()].dropna()
        if self.ss:
            # steady state, move storage coefficients
            df = df[~(df.PARGPNME.str.lower().str.startswith('ss') | df.PARGPNME.str.lower().str.startswith('sy'))]

        self.pargp = pd.concat([self.pargp, df])
        self.npargp = self.pargp.shape[0]


    def add_par(self, df, ):
        df = df.loc[:, 'PARNME PARTRANS PARCHGLIM PARVAL1 PARLBND PARUBND PARGP SCALE OFFSET DERCOM TIETO'.split()]
        if self.ss:
            df = df[~(df.PARNME.str.lower().str.startswith('ss') | df.PARNME.str.lower().str.startswith('sy'))]


        self.par = pd.concat([self.par, df])

        self.npar = self.par.shape[0]


    def fill_parval(self, pestparfile):
        # pestpar is the best parameter values file generated by pest
        parval = pd.read_csv(pestparfile, header=None, sep=' ', skipinitialspace=True, index_col=0, skiprows=1)
        self.par['PARVAL1'] = parval.loc[self.par.PARNME.str.lower(), 1].values



    def add_tied(self, df):
        assert self.par is not None, 'Read parameter data before read tied parameters'

        tied = df.iloc[:,:2].set_index(df.columns[0]).squeeze().dropna()
        # filtered those that are specified as tied in PAR
        tied_para = self.par.loc[self.par.PARTRANS == 'tied', 'PARNME'].values
        tied = tied.loc[tied_para]
        # check if any of the tieto is fixed 
        fixed = tied[(self.par.set_index('PARNME').loc[tied.values, 'PARTRANS'].str.lower() == 'fixed').values]
        if len(fixed) > 0:
            print('Found tied to fixed parameters, change them to fixed as well')
            self.par.loc[self.par.PARNME.isin(fixed.index.values), 'PARTRANS'] = 'fixed'
        
        tied = tied[~tied.index.isin(fixed.index)]
        
        self.tied = pd.concat([self.tied, tied])

    def add_obs(self, obs, weight_factor=1.0):

        df = obs['OBSNME OBSVAL WEIGHT OBGNME'.split()].dropna()
        df.WEIGHT = df.WEIGHT * weight_factor

        self.obs = pd.concat([self.obs, df])
        self.nobs = self.obs.shape[0]

        for obgp in self.obs['OBGNME'].unique():
            if obgp not in self.obsgp:
                self.obsgp.append(obgp)




    def get_control(self,):
        kw = self.control_kw
        lines = '* control data\n'

        # rstfle pestmode
        if 'rstfle' not in kw:
            kw['rstfle'] = 'restart'

        # npar nobs npargp nprior nobsgp [maxcompdim] [derzerolim]
        if 'npar' not in kw:
            kw['npar'] = self.npar or 1

        if 'nobs' not in kw:
            kw['nobs'] = self.nobs or 1

        if 'npargp' not in kw:
            kw['npargp'] = self.npargp or 1

        kw['nprior'] = self.nprior

        if 'nobsgp' not in kw:
            kw['nobsgp'] = self.nobsgp or 1

        if 'maxcompdim' not in kw:
            kw['maxcompdim'] = ''

        if 'derzerolim' not in kw:
            kw['derzerolim'] = ''


        # ntplfle ninsfle precis dpoint [numcom jacfile messfile] [obsreref]
        if 'ntplfle' not in kw: #
            kw['ntplfle'] = len(self.tpl)

        if 'ninsfle' not in kw: #
            kw['ninsfle'] = len(self.ins)

        if 'precis' not in kw:
            kw['precis'] = 'single'

        if 'dpoint' not in kw:
            kw['dpoint'] = 'point'

        if 'numcom' not in kw:
            kw['numcom'] = 1

        if 'jacfile' not in kw:
            kw['jacfile'] = 0

        if 'messfile' not in kw:
            kw['messfile'] = 0

        if 'obsreref' not in kw:
            kw['obsreref'] = ''



        # rlambda1 rlamfac phiratsuf phiredlam numlam [jacupdate] [lamforgive] [derforgive]
        if 'rlambda1' not in kw:
            kw['rlambda1'] = 10

        if 'rlamfac' not in kw: #
            kw['rlamfac'] = 2.

        if 'phiratsuf' not in kw:
            kw['phiratsuf'] = 0.3

        if 'phiredlam' not in kw:
            kw['phiredlam'] = 0.03

        if 'numlam' not in kw:
            kw['numlam'] = 10

        if 'jacupdate' not in kw:
            kw['jacupdate'] = ''

        if 'lamforgive' not in kw:
            kw['lamforgive'] = ''

        if 'derforgive' not in kw:
            kw['derforgive'] = ''

        if 'uptestmin' not in kw:
            kw['uptestmin'] = 15

        if 'uptestlim' not in kw:
            kw['uptestlim'] = 40

        # relparmax facparmax facorig [iboundstick upvecbend] [absparmax]
        if 'relparmax' not in kw: #
            kw['relparmax'] = 0.8

        if 'facparmax' not in kw: #
            kw['facparmax'] = 5.0

        if 'facorig' not in kw:
            kw['facorig'] = 0.001

        if 'iboundstick' not in kw:
            kw['iboundstick'] = ''

        if 'upvecbend' not in kw:
            kw['upvecbend'] = ''

        if 'absparmax' not in kw:
            kw['absparmax'] = ''


        # phiredswh [noptswitch] [splitswh] [doaui] [dosenreuse] [boundscale]
        if 'phiredswh' not in kw: #
            kw['phiredswh'] = 0.1

        if 'noptswitch' not in kw: #
            kw['noptswitch'] = ''

        if 'splitswh' not in kw:
            kw['splitswh'] = ''

        if 'doaui' not in kw:
            kw['doaui'] = ''

        if 'dosenreuse' not in kw:
            kw['dosenreuse'] = ''

        if 'boundscale' not in kw:
            kw['boundscale'] = ''


        # noptmax phiredstp nphistp nphinored relparstp nrelpar [phistopthresh] [lastrun] [phiabandon]
        if 'noptmax' not in kw:
            # If NOPTMAX is set to 0, PEST will not estimate parameters, nor even calculate a Jacobian matrix. Instead it will terminate execution after just one model run.
            # If NOPTMAX is set to -2 PEST will calculate the Jacobian matrix, store it in a JCO file, and then cease execution immediately.
            # Setting NOPTMAX to –1 also instructs PEST to compute the Jacobian matrix. However after doing this, PEST records the same information on its output files as that which it would normally record on completion of an inversion process.
            kw['noptmax'] = 5

        if 'phiredstp' not in kw: #
            kw['phiredstp'] = 0.005

        if 'nphistp' not in kw:
            kw['nphistp'] = 4

        if 'nphinored' not in kw:
            kw['nphinored'] = 4

        if 'relparstp' not in kw:
            kw['relparstp'] = 0.005

        if 'nrelpar' not in kw:
            kw['nrelpar'] = 4

        if 'phistopthresh,' not in kw:
            kw['phistopthresh'] = 0

        if 'lastrun' not in kw:
            kw['lastrun'] = 1

        if 'phiabandon' not in kw:
            kw['phiabandon'] = -1


        # icov icor ieig [ires] [jcosave] [verboserec] [jcosaveitn] [reisaveitn] [parsaveitn] [parsaverun]
        if 'icov' not in kw:
            kw['icov'] = 1

        if 'icor' not in kw:
            kw['icor'] = 1

        if 'ieig' not in kw:
            kw['ieig'] = 1

        if 'ires' not in kw:
            kw['ires'] = ''

        if 'jcosave' not in kw:
            kw['jcosave'] = ''

        if 'verboserec' not in kw:
            kw['verboserec'] = 'verboserec'

        if 'jcosaveitn' not in kw:
            kw['jcosaveitn'] = ''

        if 'reisaveitn' not in kw:
            kw['reisaveitn'] = ''

        if 'parsaveitn' not in kw:
            kw['parsaveitn'] = 'parsaveitn'

        if 'parsaverun' not in kw:
            kw['parsaverun'] = ''



        lines += "{0[rstfle]:<10s}{0[pestmode]:<10s}\n"
        lines += "{0[npar]:<10}{0[nobs]:<10}{0[npargp]:<10}{0[nprior]:<10}{0[nobsgp]:<10}{0[maxcompdim]:<10}{0[derzerolim]:<10}          #npar nobs npargp nprior nobsgp maxcompdim derzerolim \n"
        lines += "{0[ntplfle]:<10}{0[ninsfle]:<10}{0[precis]:<10s}{0[dpoint]:<10s}{0[numcom]:<10}{0[jacfile]:<10}{0[messfile]:<10}{0[obsreref]:<10}\n"
        lines += "{0[rlambda1]:<10}{0[rlamfac]:<10}{0[phiratsuf]:<10}{0[phiredlam]:<10}{0[numlam]:<10} uptestmin={0[uptestmin]:<3.0f} uptestlim={0[uptestlim]:<3.0f}\n"
        lines += "{0[relparmax]:<10}{0[facparmax]:<10}{0[facorig]:<10}{0[iboundstick]:<10}{0[upvecbend]:<10}{0[absparmax]:<10}\n"
        lines += "{0[phiredswh]:<10}{0[noptswitch]:<10}{0[splitswh]:<10}{0[doaui]:<10}{0[dosenreuse]:<10}{0[boundscale]:<10}\n"
        lines += "{0[noptmax]:<10}{0[phiredstp]:<10}{0[nphistp]:<10}{0[nphinored]:<10}{0[relparstp]:<10}{0[nrelpar]:<10}{0[phistopthresh]:<10}{0[lastrun]:<10}{0[phiabandon]:<10}   #noptmax\n"
        lines += "{0[icov]:<10}{0[icor]:<10}{0[ieig]:<10} {0[ires]} {0[jcosave]} {0[verboserec]} {0[jcosaveitn]} {0[reisaveitn]} {0[parsaveitn]} {0[parsaverun]}\n"

        return lines.format(kw)


    def get_svd(self, **kw):

        lines = '* singular value decomposition\n'

        # If SVDMODE is set to zero, use of singular value decomposition is de-activated. Set SVDMODE to 1 or 2 to activate it.
        # If SVDMODE is set to 1, then PEST uses singular value decomposition to solve this equation.
        #     Numerical stability is assured through truncation of singular values before they become very low or zero (see below).
        # If SVDMODE is set to 2, then PEST undertakes singular value decomposition of the Q1/2J matrix.
        #     It then evaluates a parameter upgrade using equation 6.2.4 of Doherty (2015).
        if 'svdmode' not in kw:
            kw['svdmode'] = 1

        # MAXSING is the number of singular values before truncation. Ideally this should be equal to the optimal dimensionality of the solution space.
        # set to the number of adjustable parameters
        if 'maxsing' not in kw:
            kw['maxsing'] = 10000

        # EIGTHRESH is the ratio of lowest to highest eigenvalue of the (JtQJ + λI) matrix at which singular value truncation occurs.
        #     For λ equal to zero, this is the square root of the ratio of the highest to lowest singular value of Q1/2J at
        #     which singular value truncation occurs. To ensure numerical stability of the inversion process this should be set to 5E-7 or above,
        #     for this is the value at which numerical noise can be amplified to a level where it smothers the “signal” contained in the calibration dataset.
        if 'eigthresh' not in kw:
            kw['eigthresh'] = 5e-7

        # When SVD is activated, PEST writes a file named case.svd in addition to its usual output files.
        #     If SVDMODE is set to 1, this contains singular values (arranged in decreasing order) and corresponding eigenvectors of (JtQJ + I)
        #     computed on each occasion that singular value decomposition is undertaken. It
        if 'eigwrite' not in kw:
            kw['eigwrite'] = 0


        lines += "{0[svdmode]}\n"
        lines += "{0[maxsing]:<10d}{0[eigthresh]}\n"
        lines += "{0[eigwrite]}\n"

        return lines.format(kw)

    def get_parameter_group(self):
        # self.pargp = self.pargp.style.set_properties(**{'text-align': 'left'})
        return '* parameter groups\n' + tabulate(self.pargp, showindex=False, tablefmt='plain', numalign='right', stralign='left') + '\n'

    def get_parameter(self):
        assert self.par is not None
        # self.par = self.par.style.set_properties(**{'text-align': 'left'})
        formatters={"PARVAL1": "{:<.11g}".format,
                    "PARLBND": "{:<.11g}".format,
                    "PARUBND": "{:<.11g}".format,
                    "SCALE"  : "{:<.10g}".format,
                    "OFFSET" : "{:<.10g}".format,
                    "DERCOM" : "{:<.0f}".format,
        }
        lines = '* parameter data\n' + tabulate(self.par.drop('TIETO', axis=1), showindex=False, tablefmt='plain', numalign='right', stralign='left') + '\n'
        
        tied = self.par['PARTRANS'].str.lower() == 'tied'
 
        if any(tied):
            lines += tabulate(self.par.loc[tied, ['PARNME', 'TIETO']], showindex=False, tablefmt='plain', stralign='left') + '\n'
        return lines

    def get_observation_group(self):
        return '* observation groups\n' + '\n'.join(self.obsgp) + '\n'

    def get_observation(self):
        assert self.obs is not None
        # self.obs = self.obs.style.set_properties(**{'text-align': 'left'})
        return '* observation data\n' + tabulate(self.obs, showindex=False, tablefmt='plain', numalign='right', stralign='left') + '\n'

    def set_command_line(self, cmd):
        self.cmd = cmd

    def get_aui(self, **kw):

        lines = '* automatic user intervention\n'
        # maxaui auistartopt noauiphirat auirestitn
        if 'maxaui' not in kw:
            kw['maxaui'] = int(self.nper * 0.75)

        if 'auistartopt' not in kw:
            kw['auistartopt'] = 2

        if 'noauiphirat' not in kw:
            kw['noauiphirat'] = 0.89

        if 'auirestitn' not in kw:
            kw['auirestitn'] = 3

        # auisensrat auiholdmaxchg auinumfree
        if 'auisensrat' not in kw:
            kw['auisensrat'] = 5.0

        if 'auiholdmaxchg' not in kw:
            kw['auiholdmaxchg'] = 1

        if 'auinumfree' not in kw:
            kw['auinumfree'] = 3

        # auiphiratsuf auiphirataccept nauinoaccept
        if 'auiphiratsuf' not in kw:
            kw['auiphiratsuf'] = 0.8

        if 'auiphirataccept' not in kw:
            kw['auiphirataccept'] = 0.95

        if 'nauinoaccept' not in kw:
            kw['nauinoaccept'] =  int(self.nper * 0.75 * 0.75)



        lines += "{0[maxaui]:<10}{0[auistartopt]:<10}{0[noauiphirat]:<10}{0[auirestitn]:<10}\n"
        lines += "{0[auisensrat]:<10}{0[auiholdmaxchg]:<10}{0[auinumfree]:<10}\n"
        lines += "{0[auiphiratsuf]:<10}{0[auiphirataccept]:<10}{0[nauinoaccept]:<10}\n"

        return lines.format(kw)

    def get_svdas(self, **kw):
        lines = '* svd assist\n'

        # basepestfile
        # basejacfile
        # svda_mulbpa svda_scaladj svda_extsuper svda_supdercalc svda_par_excl

        return lines.format(kw)

    def lrsq(self, **kw):
        lines = '* lsqr\n'

        # lsqrmode
        # lsqr_atol lsqr_btol lsqr_conlim lsqr_itnlim
        # lsqrwrite

        return lines.format(kw)

    def get_regul(self, **kw):
        # * regularisation
        lines = '* regularisation\n'

        # phimlim phimaccept [fracphim] [memsave]
        if 'phimlim' not in kw:
            kw['phimlim'] = 0.1

        if 'phimaccept' not in kw:
            kw['phimaccept'] = 1.05 * kw['phimlim']

        if 'fracphim' not in kw:
            kw['fracphim'] =  0.3

        if 'memsave' not in kw:
            kw['memsave'] =  ''


        # wfinit wfmin wfmax [linreg] [regcontinue]
        if 'wfinit' not in kw:
            kw['wfinit'] = 1.0

        if 'wfmin' not in kw:
            kw['wfmin'] = 1E-15

        if 'wfmax' not in kw:
            kw['wfmax'] =  1E15

        if 'linreg' not in kw:
            kw['linreg'] =  ''

        if 'regcontinue' not in kw:
            kw['regcontinue'] =  ''

        # wffac wftol iregadj [noptregadj regweightrat [regsingthresh]]
        if 'wffac' not in kw:
            kw['wffac'] = 1.3

        if 'wftol' not in kw:
            kw['wftol'] = 1E-3

        if 'iregadj' not in kw:
            kw['iregadj'] =  1

        if 'noptregadj' not in kw:
            kw['noptregadj'] =  ''

        if 'regweightrat' not in kw:
            kw['regweightrat'] =  ''

        if 'regsingthresh' not in kw:
            kw['regsingthresh'] =  ''

        lines += "{0[phimlim]:<10.5g}{0[phimaccept]:<10.5g} {0[fracphim]:<} {0[memsave]:<}\n"
        lines += "{0[wfinit]:<10.5g}{0[wfmin]:<10.5g}{0[wfmax]:<10.5g} {0[linreg]:<} {0[regcontinue]:<}\n"
        lines += "{0[wffac]:<10.5g}{0[wftol]:<10.5g} {0[iregadj]:<} {0[noptregadj]:<} {0[regweightrat]:<} {0[regsingthresh]:<10}\n"
        return lines.format(kw)

    def get_prior(self):
        # PILBL PIFAC * PARNME + PIFAC * log(PARNME) ... = PIVAL WEIGHT OBGNME
        # (one such line for each of the NPRIOR articles of prior information)
        prior = self.prior
        return '* prior information\n' + tabulate(prior, showindex=False, tablefmt='plain', ) + '\n'

    def add_prior(self, prior):
        self.control_kw['pestmode'] = 'regularisation'
        prior.columns = [c.upper() for c in prior.columns]
        prior = prior[['PINME', 'EQ', 'WEIGHT', 'OBGNME']].dropna()
        # check if here is fixed parameter in PI
        fixed = self.par.loc[(self.par.PARTRANS.str.lower().str.strip() == 'fixed') | (self.par.PARTRANS.str.lower().str.strip() == 'tied'), 'PARNME']
        fixed = '\n'.join(fixed).lower().split()
        spi = prior['EQ'].to_string(index=False, header=False)

        for ss in ['(', ')', '+', ' - ', '*', '=', '/', 'log',]:
            spi = spi.replace(ss, ' ')
        included = []
        for s in spi.split('\n'):
            s = [ss for ss in s.lower().split() if not is_number(ss)]
            included.append(not any([p in fixed for p in s]) )
        prior = prior[included]

        if self.ss:
            prior = prior[ (prior.EQ.str.lower().str.find('ss') == -1) & (prior.EQ.str.lower().str.find('sy') == -1) ]

        for obgp in prior.OBGNME.unique():
            if obgp not in self.obsgp:
                self.obsgp.append(obgp)

        self.prior = pd.concat([self.prior, prior])
        self.nprior = self.prior.shape[0]




    def add_io(self, df):
        # df = df.iloc[:,:2].dropna()
        for i, r in df.iterrows():
            t = r.iloc[0].upper()
            f  = r.iloc[1]
            fm = r.iloc[2]
            if t == 'TPL':
                self.tpl.append((f, fm))
            elif t == 'INS':
                self.ins.append((f, fm))
            elif t == 'CMD':
                self.set_command_line(' '.join([str(c)  for c in r.iloc[1:] if not pd.isna(c)]))

    def add_pp(self, df):
        """add the PEST++ commands

        Args:
            df (_type_): _description_
        """
        for i, r in df.iterrows():
            self.pp.append([r[0], r[1]])


    def add_tpl(self, f, fm):
        self.tpl.append((f, fm))

    def add_ins(self, f, fm):
        self.ins.append((f, fm))

    def dump_tpl(self, pstfile):
        par = self.par[['PARNME', 'PARVAL1']].copy()
        par['PARVAL1'] = '~       ' + par['PARNME'] + '       ~'
        pstdir = os.path.dirname(pstfile) or '.'
        with open(pstdir + '/dump.tpl', 'w', newline='\r\n') as f:
            f.write('ptf ~\n')
            f.write(par.to_string(index=False, header=False))

    def write_pest_pst(self, file):

        svd   = True
        lrsq  = False
        aui   = False
        svdas = False

        if self.obs is None or self.par is None or self.pargp is None:
            raise AttributeError('Need to read parameter and observation')

        if self.tpl is [] or self.ins is []:
            raise AttributeError('Need to add template and instruction files')

        if self.cmd == '':
            raise AttributeError('Need to set model command line')


        self.nobsgp = len(self.obsgp)

        lines = 'pcf\n'

        ### Control Data Section
        lines += self.get_control()

        ### Singular Value Decomposition Section
        if svd:
            lines += self.get_svd()

        ### LSQR Section
        if lrsq:
            lines += self.get_lrsq()

        ### Automatic User Intervention Section
        if aui:
            lines += self.get_aui()

        ### SVD Assist Section
        if svdas:
            lines += self.get_svdas()

        ### Parameter Groups Section
        lines += self.get_parameter_group()

        ### Parameter Data Section
        lines += self.get_parameter()

        ### Observation Groups Section
        lines += self.get_observation_group()

        ### Observation Data Section
        lines += self.get_observation()

        ### Derivatives Command Line Section
        # TODO

        ### Model Command Line Section
        lines += '* model command line\n' + self.cmd.strip() + '\n'

        ### Model Input/Output Section
        io = pd.DataFrame(self.tpl + self.ins)
        lines += '* model input/output\n' + tabulate(io, showindex=False, tablefmt='plain', numalign='right', stralign='left') + '\n'

        ### Prior Information Section
        if self.nprior > 0:
             lines += self.get_prior()

        ### Predictive Analysis Section
        if self.pestmode == 'prediction':
            pass

        ### Regularisation Section
        if self.pestmode == 'regularisation':
             lines += self.get_regul()

        ### Pareto Section
        if self.pestmode == 'pareto':
            pass

        for k, v in self.pp:
            lines += f'++{k}({v})\n'

        ### dump all parameters to one template file
        self.dump_tpl(file)

        with open(file, 'w', newline='') as f:
            f.write(lines)



#%%

if __name__ == '__main__':
    import argparse
    parser = argparse.ArgumentParser()
    parser.add_argument('pstfile', default='new.pst', )
    parser.add_argument('mode', default='estimation')
    parser.add_argument('--set_ctl_xls', help='')
    parser.add_argument('--set_ctl_csv', help='')

    parser.add_argument('--add_obs_xls',   action='append', help='')
    parser.add_argument('--add_par_xls',   action='append', help='')
    parser.add_argument('--add_pargp_xls', action='append', help='')
    parser.add_argument('--add_tied_xls',  action='append', help='')
    parser.add_argument('--add_prior_xls', action='append', help='')
    parser.add_argument('--add_io_xls',    action='append', help='')
    parser.add_argument('--add_pp_xls',    action='append', help='')
    parser.add_argument('--add_obs_csv',   action='append', help='')
    parser.add_argument('--add_par_csv',   action='append', help='')
    parser.add_argument('--add_pargp_csv', action='append', help='')
    parser.add_argument('--add_tied_csv',  action='append', help='')
    parser.add_argument('--add_prior_csv', action='append', help='')
    parser.add_argument('--add_io_csv',    action='append', help='')
    parser.add_argument('--add_pp_csv',    action='append', help='')


    args = parser.parse_args()
    # print(args)
    control=None
    if args.set_ctl_xls:
        x, s = args.set_ctl_xls.split(',')
        control = pd.read_excel(x, s)
    if args.set_ctl_csv:
        control = pd.read_csv(args.set_ctl_csv)

    pst = pest_pst(args.mode, control=control) # regularisation     estimation
    print(f'Creating {args.pstfile} in {args.mode} mode...')
    for t in ['par', 'pargp', 'tied', 'prior', 'obs', 'io', 'pp']:
        #if args.mode.lower() != 'regularisation' and t == 'prior': continue
        xlss = getattr(args, f'add_{t}_xls')
        if xlss:
            for xls in xlss:
                x, s = xls.split(',')
                print(f'Adding {t:8s} from {x}@{s}')
                df = pd.read_excel(x, s)
                df.columns = [c.upper() for c in df.columns]
                getattr(pst, f'add_{t}')(df)

        csvs = getattr(args, f'add_{t}_csv')
        if csvs:
            for csv in csvs:
                print(f'Adding {t} from {csv}')
                df = pd.read_csv(csv)
                df.columns = [c.upper() for c in df.columns]
                getattr(pst, f'add_{t}')(df)


    pst.write_pest_pst(args.pstfile)
